# crypto | Полный рандом | easy

## Информация
> ООО, мне за эту разработку такую премию дадут, никакие хакеры не смогут взломать мой шифр! Наконец-то поеду отдыхать на море, а то так устал разрабатывать эти ваши шифры. Я настолько уверен в своем шифре, что дам вам такие подсказки: в открытом тексте используется только маленькие буквы английского алфавита + {}_

## Деплой
Не требуется

## Выдать участникам
Содержимое [папки](public/)

## Описание
Для решения данной задачи требуется перебрать возможные seed для рандома, чтобы создать ключи и расшифровать данный текст. Анализируя код, видим, что seed береться из количество секунд, которые прошли с начала 1 января 1970 на момент запуска программы. Посмотрев метаданные файла можно понять, что файл модифицирвали последний раз 17.10.2024 в 23:46. Предположим, что файл модифицировали, чтобы добавить вывод программы. Возможно программу запустили и лишь спустя время добавили вывод, поэтому надо перебрать все возможные seed, которые могут получиться с начало 17.10.2024 00:00:00 по 17.10.2024 23:59:59

Подумаем о том, как будет писать дешифроватор.
Заметим, что у нас, если число в зашифрованном текст нечетное, то это означает, что оно получено в ходе суммирования символа флага и ключа. Для доказательства рассмотрим все варианты:
```
(ч - н) ^ (ч + н) = н ^ н = ч
(н - ч) ^ (н + ч) = н ^ н = ч
(ч - ч) ^ (ч + ч) = ч ^ ч = ч
(н - н) ^ (н + н) = ч ^ ч = ч
```
Важно не забыть, что на один шифросимвол в случае, если его проксорили, когда шифровали, возможны несколько вариантов исходного символа!
Поэтому, когда у нас в случае, когда не суммирование, нужно искать всевозможные символы, из которых получиться данный шифротест.

Напишем функцию дешифратор, который будет принимать на вход шифротекст и возможный ключ, для каждого символа шифротекста будет создавать массив возможных символов открытого.
```
def decrypt(key, enc):
    # функция возвращет массив из массивов, где в каждом субмассиве варинты 
    decs = []
    for i in range(len(enc)):
        tmp = []
        if enc[i] - key[i] >= 32 and enc[i] - key[i] <= 126:
            if enc[i] - key[i] >= key[i]:
                tmp.append(chr(enc[i] - key[i]))
        if enc[i] % 2 == 0: # если нечетный, то точно сумма
            for j in (string.ascii_lowercase + string.digits + "_}{"):
                if (ord(j) + key[i]) ^ (key[i] - ord(j)) == enc[i]:
                    if key[i] > ord(j): # проверяем попали мы бы в xor, когда шифровали открытый текст
                        tmp.append(j)
        decs.append(tmp)
    return decs
```
Потом нужно отфильтровать варианты, где у нас для какого-то шифросимвола нет вообще вариантом из открытого текста, создадим все варианты флагов и начнем проверять какой из них подходит.
Для того, чтобы упросить себе жизнь, давайте посмотрим сколько в флаге есть существующих английских слов и выведем те флаги, где из больше, чем 4. В итоге получим около 8 вариантов, самых подходящий по смыслу ctf{cipher_is_weak_very_sad}
## Флаг

`ctf{cypher_is_weak_very_sad}`
